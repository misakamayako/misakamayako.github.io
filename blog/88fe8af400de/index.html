<!DOCTYPE html><html lang="zh-hans" class="h-full w-full m-0"> <head><meta charset="utf-8"><link rel="icon" type="image/jepg" href="/favicon.jpg"><meta name="viewport" content="width=device-width"><meta name="google-site-verification" content="-RgOsAO7rMTpJ8vNk8-ILdAA8VmiTEUc9HiUVVTKeEs"><meta name="generator" content="Astro v5.13.5"><title>✨御坂网络-JDK 22 FFM API 与传统 JNI 的对比✨</title><link rel="stylesheet" href="/_astro/index.CVE_tfyK.css">
<style>/*! tailwindcss v4.1.12 | MIT License | https://tailwindcss.com */
@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-border-style:solid}}}.okTgGW_footer{font-size:var(--text-sm,.875rem);line-height:var(--tw-leading,var(--text-sm--line-height,calc(1.25/.875)));color:var(--color-stone-400,#a6a09b);text-align:center;padding-block:calc(var(--spacing,.25rem)*4);border-top-color:var(--color-zinc-50,#fafafa);border-top-style:var(--tw-border-style);background-color:var(--color-slate-900,#0f172b);border-top-width:2px;width:100%;position:relative}@supports (color:color(display-p3 0 0 0)){.okTgGW_footer{color:var(--color-stone-400,color(display-p3 .647628 .627105 .61098));border-top-color:var(--color-zinc-50,color(display-p3 .980256 .980256 .980256));background-color:var(--color-slate-900,color(display-p3 .0639692 .0891152 .163036))}}@supports (color:lab(0% 0 0)){.okTgGW_footer{color:var(--color-stone-400,lab(66.2166% 1.88047 3.20326));border-top-color:var(--color-zinc-50,lab(98.26% -.0000298023 0));background-color:var(--color-slate-900,lab(7.78673% 1.82345 -15.0537))}}.okTgGW_footer a{text-decoration-line:underline}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}
/*! tailwindcss v4.1.12 | MIT License | https://tailwindcss.com */
@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-border-style:solid;--tw-translate-x:0;--tw-translate-y:0;--tw-translate-z:0}}}.q0UmqG_menu{height:calc(var(--spacing,.25rem)*16);padding-right:calc(var(--spacing,.25rem)*16);border-bottom-color:var(--color-zinc-50,#fafafa);border-bottom-style:var(--tw-border-style);text-align:right;border-bottom-width:2px}@supports (color:color(display-p3 0 0 0)){.q0UmqG_menu{border-bottom-color:var(--color-zinc-50,color(display-p3 .980256 .980256 .980256))}}@supports (color:lab(0% 0 0)){.q0UmqG_menu{border-bottom-color:var(--color-zinc-50,lab(98.26% -.0000298023 0))}}.q0UmqG_menu a{padding-inline:calc(var(--spacing,.25rem)*2);padding-block:calc(var(--spacing,.25rem)*2);font-size:var(--text-xl,1.25rem);line-height:var(--tw-leading,var(--text-xl--line-height,calc(1.75/1.25)));color:var(--color-zinc-50,#fafafa);margin-top:calc(var(--spacing,.25rem)*2.5);display:inline-block}@supports (color:color(display-p3 0 0 0)){.q0UmqG_menu a{color:var(--color-zinc-50,color(display-p3 .980256 .980256 .980256))}}@supports (color:lab(0% 0 0)){.q0UmqG_menu a{color:var(--color-zinc-50,lab(98.26% -.0000298023 0))}}@media (hover:hover){.q0UmqG_menu a:hover{--tw-translate-y:calc(var(--spacing,.25rem)*-.5);translate:var(--tw-translate-x)var(--tw-translate-y);color:var(--color-sky-500,#00a5ef)}@supports (color:color(display-p3 0 0 0)){.q0UmqG_menu a:hover{color:var(--color-sky-500,color(display-p3 .219113 .639027 .931479))}}@supports (color:lab(0% 0 0)){.q0UmqG_menu a:hover{color:var(--color-sky-500,lab(63.3038% -18.433 -51.0407))}}}.q0UmqG_menu a{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function,cubic-bezier(.4,0,.2,1)));transition-duration:var(--tw-duration,var(--default-transition-duration,.15s));transition-property:transform,translate,scale,rotate;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function,cubic-bezier(.4,0,.2,1)));transition-duration:var(--tw-duration,var(--default-transition-duration,.15s))}.q0UmqG_navLink{padding-inline:calc(var(--spacing,.25rem)*2);padding-block:calc(var(--spacing,.25rem)*2);font-size:var(--text-xl,1.25rem);line-height:var(--tw-leading,var(--text-xl--line-height,calc(1.75/1.25)));color:var(--color-zinc-50,#fafafa);margin-top:calc(var(--spacing,.25rem)*2.5);display:inline-block}@supports (color:color(display-p3 0 0 0)){.q0UmqG_navLink{color:var(--color-zinc-50,color(display-p3 .980256 .980256 .980256))}}@supports (color:lab(0% 0 0)){.q0UmqG_navLink{color:var(--color-zinc-50,lab(98.26% -.0000298023 0))}}@media (hover:hover){.q0UmqG_navLink:hover{color:var(--color-sky-500,#00a5ef)}@supports (color:color(display-p3 0 0 0)){.q0UmqG_navLink:hover{color:var(--color-sky-500,color(display-p3 .219113 .639027 .931479))}}@supports (color:lab(0% 0 0)){.q0UmqG_navLink:hover{color:var(--color-sky-500,lab(63.3038% -18.433 -51.0407))}}}.q0UmqG_navLink{transition:color .4s}.q0UmqG_avatar{float:right;border-radius:.25rem;display:inline-block;overflow:hidden}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-translate-x{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-y{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-z{syntax:"*";inherits:false;initial-value:0}
</style>
<link rel="stylesheet" href="/_astro/_slug_.BkXjpIp6.css"><script type="module" src="/_astro/page.V2R8AmkL.js"></script></head> <body class="w-full h-full flex flex-col">  <div class="bg-slate-800 h-screen flex flex-col"> <div class="bg-slate-700 w-full"> <div class="q0UmqG_avatar"> <img src="/favicon.jpg" width="64" height="64" alt=""> </div> <nav class="q0UmqG_menu"> <a href="/" class="q0UmqG_navLink">home</a> <a href="/blog/" class="q0UmqG_navLink">blog</a> <a href="/utils/" class="q0UmqG_navLink">utils</a> <a href="/dream-map/" class="inline-block">dream map</a> <a href="/album/" class="q0UmqG_navLink">album</a> <a href="/about-me/" class="q0UmqG_navLink">about me</a> </nav> </div> <div class="flex p-4 grow flex-row h-full overflow-hidden"> <aside class="w-1/4 ml-4 md:block min-w-[200px]"> <div class="sticky top-4 space-y-6"> <div class="bg-slate-700 p-4 rounded-lg"> <img src="/avatar.jpg" class="w-16 h-16 rounded-full mx-auto"> <p class="text-white text-center mt-2">作者：misakamayako</p>  <p class="text-white text-center mt-2">发布时间：2025/08/01</p> </div> <div class="bg-slate-700 p-4 rounded-lg"> <h3 class="text-emerald-400 mb-2">简介</h3> <p class="text-white font-light mb-2">本文全面对比了 JDK 22 引入的 Foreign Function &amp; Memory API（FFM API）与传统 Java Native Interface（JNI）在架构设计、性能、安全性、可维护性、跨平台兼容性等方面的异同与优劣。并深入探讨了 C/C++ 代码在两种调用方式下是否需要不同实现，以及在实际项目中如何选择更合适的本地互操作技术。</p> </div> <!-- 2. 文章目录 --> <!--<div class="bg-slate-700 p-4 rounded-lg">--> <!--    <h3 class="text-emerald-400 mb-2">本文目录</h3>--> <!--    &lt;!&ndash;<TOC client:load /> &ndash;&gt;--> <!--</div>--> <!-- 3. 随机文章 --> <div class="bg-slate-700 p-4 rounded-lg"> <h3 class="text-emerald-400 mb-2">随便看看</h3> <div class="flex flex-wrap gap-2"> <a class="px-3 py-1 bg-slate-600 rounded-full text-sm text-white hover:bg-emerald-500 transition" href="/blog/15b29448545c/"> Web Worker 类型概览 </a><a class="px-3 py-1 bg-slate-600 rounded-full text-sm text-white hover:bg-emerald-500 transition" href="/blog/18b5a9299ef3/"> Kotlin 引用操作符(::)的使用 </a><a class="px-3 py-1 bg-slate-600 rounded-full text-sm text-white hover:bg-emerald-500 transition" href="/blog/26deb11a071a/"> TypeScript 中的简易事件总线实现与使用指南 </a> </div> </div> </div> </aside> <main class="grow h-full overflow-auto w-3/4 px-8"> <article class="text-zinc-200 mb-2 prose lg:prose-xl prose-stone
                 prose-headings:text-current prose-strong:text-current prose-code:text-current
                 prose-a:text-violet-200 prose-blockquote:text-stone-100">  <header> <h1>JDK 22 FFM API 与传统 JNI 的对比</h1> </header> <p>JDK 22 引入了<strong>外部函数和内存 API（FFM API）</strong>，提供了一种全新的 Java 与本地代码互操作方案。与传统的 JNI 相比，FFM API 采用纯 Java 的编程模型，通过 <code>Linker</code>、<code>MethodHandle</code>、<code>MemorySegment</code> 等类直接调用 C 函数和管理本地内存，无需编写 JNI Glue 代码或生成头文件。下面从架构设计、性能、安全、可维护性、易用性、跨平台兼容性等维度详细对比两者的差异与优劣，并讨论 C/C++ 代码实现和适用场景。</p>
<h2 id="架构设计与调用方式">架构设计与调用方式</h2>
<ul>
<li>
<p><strong>JNI</strong>：Java 侧通过 <code>native</code> 关键字声明本地方法（无方法体），并使用 <code>System.loadLibrary</code> 加载本地库。对应的 C/C++ 代码必须使用 JNI 规范的函数签名，形式如 <code>Java_包名_类名_方法名(JNIEnv *env, jclass/jobject, 参数…)</code>。调用时，Java 与本地代码之间通过 <code>JNIEnv</code> 结构体指针进行交互：Java 值需要转换为 JNI 类型（如 <code>jintArray</code>、<code>jstring</code> 等），C 代码通过 <code>(*env)->GetXXX</code> 系列函数访问数据或调用 Java 方法。整个调用模型偏向“Native 优先”，需要手动处理数组/字符串拷贝、引用管理和异常检查。</p>
<p>例如，使用 JNI 调用 C 函数并返回整数的示例：</p>
</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="kotlin"><code><span class="line"><span style="color:#F97583">external</span><span style="color:#F97583"> fun</span><span style="color:#B392F0"> add</span><span style="color:#E1E4E8">(a: </span><span style="color:#B392F0">Int</span><span style="color:#E1E4E8">, b: </span><span style="color:#B392F0">Int</span><span style="color:#E1E4E8">): </span><span style="color:#B392F0">Int</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">fun</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#E1E4E8">    System.</span><span style="color:#B392F0">loadLibrary</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"native"</span><span style="color:#E1E4E8">)  </span><span style="color:#6A737D">// 直接在main里加载</span></span>
<span class="line"><span style="color:#B392F0">    println</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">add</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">))            </span><span style="color:#6A737D">// 调用native方法</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>对应的 C/C++ 实现：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">#include</span><span style="color:#9ECBFF"> &#x3C;jni.h></span></span>
<span class="line"><span style="color:#E1E4E8">JNIEXPORT jint JNICALL </span><span style="color:#B392F0">Java_MainKt_add</span><span style="color:#E1E4E8">(JNIEnv </span><span style="color:#F97583">*</span><span style="color:#FFAB70">env</span><span style="color:#E1E4E8">, jclass </span><span style="color:#FFAB70">cls</span><span style="color:#E1E4E8">, jint </span><span style="color:#FFAB70">a</span><span style="color:#E1E4E8">, jint </span><span style="color:#FFAB70">b</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> a </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> b;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<ul>
<li><strong>FFM API</strong>：Java 侧使用 <code>java.lang.foreign</code> 包提供的类。通过 <code>Linker</code> 查找并绑定本地函数地址，然后使用 <code>MethodHandle</code> 调用“下溢调用”（downcall）。同时使用 <code>MemorySegment</code>（和 <code>Arena</code>）分配并管理本地内存。整个调用过程纯粹在 Java 中完成，无需任何 JNI C 代码。FFM 的设计目标是“<strong>Java 优先</strong>”，即在 Java 代码中直接描述调用签名和内存布局，再由底层自动进行参数拷贝和内存管理。如下示例通过 FFM API 调用 C 库中的 <code>add</code>：</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="kotlin"><code><span class="line"><span style="color:#F97583">fun</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Arena.</span><span style="color:#B392F0">ofConfined</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">use</span><span style="color:#E1E4E8"> { arena </span><span style="color:#F97583">-></span></span>
<span class="line"><span style="color:#F97583">  val</span><span style="color:#E1E4E8"> linker </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Linker.</span><span style="color:#B392F0">nativeLinker</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#F97583">  val</span><span style="color:#E1E4E8"> os </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> System.</span><span style="color:#B392F0">getProperty</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"os.name"</span><span style="color:#E1E4E8">).</span><span style="color:#B392F0">lowercase</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#6A737D">  // 加载动态库</span></span>
<span class="line"><span style="color:#F97583">  val</span><span style="color:#E1E4E8"> libPath </span><span style="color:#F97583">=</span><span style="color:#F97583"> when</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">    os.</span><span style="color:#B392F0">contains</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"win"</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-></span><span style="color:#9ECBFF"> "native.dll"</span></span>
<span class="line"><span style="color:#E1E4E8">    os.</span><span style="color:#B392F0">contains</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"mac"</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-></span><span style="color:#9ECBFF"> "libnative.dylib"</span></span>
<span class="line"><span style="color:#F97583">    else</span><span style="color:#F97583"> -></span><span style="color:#9ECBFF"> "libnative.so"</span><span style="color:#6A737D"> // Linux/BSD</span></span>
<span class="line"><span style="color:#E1E4E8"> }</span></span>
<span class="line"><span style="color:#F97583">  val</span><span style="color:#E1E4E8"> symbolLookup </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> SymbolLookup.</span><span style="color:#B392F0">libraryLookup</span><span style="color:#E1E4E8">(libPath, arena)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  // 查找 add 函数符号</span></span>
<span class="line"><span style="color:#F97583">  val</span><span style="color:#E1E4E8"> addHandle: </span><span style="color:#B392F0">MethodHandle</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> linker.</span><span style="color:#B392F0">downcallHandle</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#E1E4E8">      symbolLookup.</span><span style="color:#B392F0">find</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"add"</span><span style="color:#E1E4E8">).</span><span style="color:#B392F0">orElseThrow</span><span style="color:#E1E4E8">(),</span></span>
<span class="line"><span style="color:#E1E4E8">      FunctionDescriptor.</span><span style="color:#B392F0">of</span><span style="color:#E1E4E8">(ValueLayout.JAVA_INT, ValueLayout.JAVA_INT, ValueLayout.JAVA_INT)</span></span>
<span class="line"><span style="color:#E1E4E8">  )</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  val</span><span style="color:#E1E4E8"> result </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> addHandle.</span><span style="color:#B392F0">invoke</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">as</span><span style="color:#E1E4E8"> Int</span></span>
<span class="line"><span style="color:#B392F0">  println</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"3 + 5 = </span><span style="color:#79B8FF">$result</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>对应的 C/C++ 实现：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">  int</span><span style="color:#B392F0"> add</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#FFAB70"> a</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> b</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> a </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> b;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span></code></pre>
<p>在这个示例中，没有任何 JNI 头文件或 C 代码定义；所有绑定、签名和内存管理都在 Java 端完成。表明 FFM API 让“纯 Java 与本地代码对话”，不需要 JNI Glue 代码。这种设计简化了调用过程：Java 代码用 <code>FunctionDescriptor</code> 定义函数签名，用 <code>MemorySegment</code> 表示本地缓冲区，调用结束后 <code>Arena</code> 自动释放内存。</p>
<ul>
<li><strong>数据和内存传递</strong>：JNI 原本只支持基本类型和 Java 对象作为参数（需要借助 <code>GetXXXArrayElements</code>、<code>GetStringUTFChars</code> 等方法处理数据），而 FFM API 提供了灵活的内存操作接口。Java 可通过 <code>MemorySegment</code> 对象直接映射任意结构体，使用 <code>MemoryLayout</code>/<code>VarHandle</code> 方便地读写本地数据结构。例如，可以直接定义 C 结构体布局，分配 <code>MemorySegment</code> 并读写字段，避免手动计算偏移。FFM 取代了 JNI 中难用的 <code>DirectByteBuffer</code> 方案，提供了更安全、更直观的方式来访问外部内存。</li>
</ul>
<h2 id="性能表现">性能表现</h2>
<ul>
<li>
<p><strong>调用开销</strong>：JNI 每次调用都会发生 Java 与本地环境之间的上下文切换，通常开销较大。FFM 通过减少必要的转换步骤来降低开销，并利用底层优化（如 JIT inline）提升效率。</p>
</li>
<li>
<p><strong>向量与并行</strong>：FFM API 与新一代向量 API 结合紧密，可直接支持 SIMD 等硬件特性，实现高性能的向量计算。此外，FFM 允许用户自定义分配器并重复利用 <code>MemorySegment</code>，以进一步减少分配开销。相比之下，JNI 不支持此类优化，只能依赖手工管理的内存分配。</p>
</li>
<li>
<p><strong>整体性能</strong>：总体而言，FFM 旨在“通过减少开销来提升性能”。Oracle 开发者指出，FFM 在很多场景下性能已达到或超过 JNI 水平。比如借助 JIT 优化和向量化，FFM 下的本地调用可以与纯 C 代码媲美，而 JNI 由于层层封装往往速度稍低。随着 JDK 22 的发布，FFM 对字符串、数组等转换进行了大量优化，使其性能显著优于传统 JNI。</p>
</li>
</ul>
<h2 id="安全性">安全性</h2>
<ul>
<li>
<p><strong>JNI 安全问题</strong>：由于 JNI 允许编写任意 C/C++ 代码，开发者必须自行处理内存管理和类型转换。传统 JNI 易出现内存泄漏、缓冲区溢出、空指针访问等问题，一旦处理不当就可能导致程序崩溃甚至安全漏洞。例如，使用 <code>GetStringUTFChars</code> 需要手动释放， <code>NewGlobalRef</code> 需避免泄漏。JNI 本身对 Java 对象访问缺乏静态检查，容易出错。</p>
</li>
<li>
<p><strong>FFM 安全机制</strong>：FFM API 引入了多项内置安全措施。<code>MemorySegment</code> 在默认情况下会进行边界检查，防止越界访问；<code>Arena</code> 自动管理本地内存生命周期，出作用域即释放，减少泄漏风险。此外，FFM 的函数签名（<code>FunctionDescriptor</code>）在编译时可检查参数类型和数量是否匹配，降低调用错误率。阿里云社区指出，FFM 对类型检查和内存管理进行了全面升级，可以减少类型不匹配或内存泄漏导致的崩溃和安全问题。Java 团队也表示，相比 JNI 的“不安全”方法，FFM 的不安全操作易于从 Java 代码中调用，并且通过更多限制（例如 JEP 472 对JNI使用的限制）提高了整体安全性。</p>
</li>
<li>
<p><strong>访问权限控制</strong>：在更高版本的 JDK 中，Java 开始对本地访问施加严格控制。JEP 472 即建议在未来对 JNI 调用发出警告或错误。FFM API 同样受限于“本地访问”策略，但由于 FFM 不支持直接访问 Java 对象（只能操作原生数据），对 JVM 内部状态干扰较少。因此，开发者可以更安全地在 Java 代码中使用 FFM，从而减少产生 <code>--enable-native-access</code> 等安全风险。</p>
</li>
</ul>
<h2 id="可维护性与易用性">可维护性与易用性</h2>
<ul>
<li>
<p><strong>JNI 的复杂性</strong>：传统 JNI 编程繁琐，需编写大量样板代码：生成头文件、实现 <code>JNIEXPORT</code> 函数、手动转换类型、管理引用等。这些步骤容易出错，调试也麻烦。例如，一个简单的本地调用就要涉及 Java 类、C 头文件、C 源文件、编译脚本等多个环节。任何 Java 类名或方法签名的微小变动都可能导致 JNI 链接失败。</p>
</li>
<li>
<p><strong>FFM 的简洁性</strong>：FFM API 设计简洁，使用纯 Java 代码即可完成本地调用和数据访问。明确指出，“无需 JNI Glue 代码，无需本地编译麻烦，只需纯 Java 调用本地函数”。Java 开发者可以直接在 IDE 编写代码，无需外部工具（如 <code>javah</code>）和 C/C++ 编译环境。常用的数据布局和结构体可用 <code>MemoryLayout</code> 简单描述，访问字段使用 <code>VarHandle</code>，避免了手动计算偏移量。Oracle 称 FFM 大幅<strong>减少样板代码</strong>和所需的原生编程知识，提高了开发效率。</p>
</li>
<li>
<p><strong>工具支持</strong>：FFM 还配套了 <code>jextract</code> 工具，可以根据 C 头文件自动生成相应的 Java 绑定类。使用 <code>jextract</code>，开发者只需指向 <code>.h</code> 文件，便可得到完整的 Java 接口定义，进一步免除了手写包装。这样，FFM 不仅在语言层面易用，还拥有自动化工具生态，大幅降低了维护成本。</p>
</li>
<li>
<p><strong>内存管理简化</strong>：JNI 中的本地内存需要显式释放，不当使用容易引发泄漏和悬挂引用。而 FFM 的 <code>Arena</code> 在退出作用域时自动释放分配的 <code>MemorySegment</code>。这种 try-with-resources 的使用模式，大大简化了内存管理。Belief-driven-design 博客也总结：FFM 提供了更简单且更安全的内存管理抽象，减少了可能的内存泄漏。</p>
</li>
</ul>
<h2 id="跨平台兼容性">跨平台兼容性</h2>
<ul>
<li>
<p><strong>JNI 的限制</strong>：虽然 JNI 规范本身跨平台，但每种操作系统/CPU 架构都需要提供编译后的本地库（.so、.dll 等），并确保正确加载。不同平台可能存在 ABI 差异或对齐规则不同，JNI 接口代码常常需要针对平台进行调整。正因如此，以前的 Java 版本存在多种原生接口规范（如 Netscape JRI、RNI）并存的情况。即使现在大多数 JVM 遵循 JNI，开发者仍需为每个平台维护编译流程。</p>
</li>
<li>
<p><strong>FFM 的优势</strong>：FFM API 采用标准的 C ABI（多数通过 libffi 实现），并内置对 Linux、macOS、Windows、AIX 等平台的支持。只要目标平台有相应的 C 库，Java 程序即可通过 FFM 调用，无需修改 Java 代码或重新生成 JNI 接口。Belief-driven-design 博客指出，FFM 有“更好的可移植性”，因为它不再依赖复杂而脆弱的 JNI 样板。在可移植性方面，FFM 让跨平台开发更加平滑：只需使用统一的 Java API，由 JVM 负责适配底层 ABI，从而避免了传统 JNI 在不同系统间反复编译的麻烦。</p>
</li>
</ul>
<h2 id="cc-代码实现差异">C/C++ 代码实现差异</h2>
<ul>
<li>
<p><strong>JNI 实现</strong>：采用 JNI 时，C/C++ 侧必须使用 JNI 头文件并按照固定命名规则编写本地方法。例如，Java 类 <code>com.example.Foo</code> 中声明了 <code>public static native int bar(int x)</code>，对应的 C 函数签名必须为 <code>Java_com_example_Foo_bar(JNIEnv *env, jclass cls, jint x)</code>。函数体中通常通过 <code>env</code> 调用 API（如 <code>NewIntArray</code>、<code>SetByteArrayRegion</code> 等）实现与 Java 侧的数据互转。复杂结构体需要在 Java 侧写相应的 JNI 代码手动拆包。每新增或修改一个 native 方法，都需要重新生成头文件、编译并部署新的本地库。</p>
</li>
<li>
<p><strong>FFM 实现</strong>：使用 FFM 时，一般不需要编写任何新的 C 函数来适配 Java。Java 代码可以直接绑定现有的 C 库函数，只要这些函数遵循常规 C 签名即可。例如，如果 C 库中已有 <code>int add(int,int)</code>，只需在 Java 端调用 <code>Linker.downcallHandle</code> 绑定它，无需在 C 端专门实现带 <code>JNIEnv*</code> 的包装函数。也就是说，现有的 C/C++ 库往往可以原样使用，FFM 只是在 Java 侧做调用。对比而言，JNI 要求 C 端以特殊方式导出函数（使用 <code>JNIEXPORT JNICALL</code> 等），而 FFM 没有此要求。</p>
</li>
<li>
<p><strong>数据结构处理</strong>：在 JNI 中，Java 对象和数组需要转换为原生类型（如 <code>jobject</code>, <code>jarray</code>），不支持直接访问 C 结构体。FFM 允许在 Java 端用 <code>MemoryLayout.structLayout</code> 描述 C 结构体布局，然后通过 <code>MemorySegment</code> 进行读写。举例来说，C 语言中的 <code>struct Point { int x; int y; }</code>，在 FFM 中可用：</p>
</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="kotlin"><code><span class="line"><span style="color:#F97583">fun</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">(){</span></span>
<span class="line"><span style="color:#F97583">    val</span><span style="color:#E1E4E8"> point: </span><span style="color:#B392F0">MemoryLayout</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> MemoryLayout.</span><span style="color:#B392F0">structLayout</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#E1E4E8">        ValueLayout.JAVA_INT.</span><span style="color:#B392F0">withName</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"x"</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">        ValueLayout.JAVA_INT.</span><span style="color:#B392F0">withName</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"y"</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">    )</span></span>
<span class="line"><span style="color:#F97583">    val</span><span style="color:#E1E4E8"> xH </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> point.</span><span style="color:#B392F0">varHandle</span><span style="color:#E1E4E8">(PathElement.</span><span style="color:#B392F0">groupElement</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"x"</span><span style="color:#E1E4E8">))</span></span>
<span class="line"><span style="color:#F97583">    val</span><span style="color:#E1E4E8"> yH </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> point.</span><span style="color:#B392F0">varHandle</span><span style="color:#E1E4E8">(PathElement.</span><span style="color:#B392F0">groupElement</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"y"</span><span style="color:#E1E4E8">))</span></span>
<span class="line"><span style="color:#E1E4E8">    Arena.</span><span style="color:#B392F0">ofConfined</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">use</span><span style="color:#E1E4E8"> { arena </span><span style="color:#F97583">-></span></span>
<span class="line"><span style="color:#F97583">        val</span><span style="color:#E1E4E8"> pt </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> arena.</span><span style="color:#B392F0">allocate</span><span style="color:#E1E4E8">(point)</span></span>
<span class="line"><span style="color:#E1E4E8">        xH.</span><span style="color:#B392F0">set</span><span style="color:#E1E4E8">(pt, </span><span style="color:#79B8FF">0L</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">10</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">        yH.</span><span style="color:#B392F0">set</span><span style="color:#E1E4E8">(pt, </span><span style="color:#79B8FF">0L</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">20</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>而在 JNI 中，处理同样结构体要么通过字节缓冲区手动拼凑，要么写很多 <code>Get/Set</code> 调用，远不如 FFM 简洁直观。</p>
<ul>
<li><strong>回调（Upcall）</strong>：目前 FFM API 主要支持 Java 调用原生函数（downcall）。如果需要从 C 代码回调 Java 方法（upcall），JNI 目前还更为成熟：JNI 可在 native 代码中通过 <code>(*env)->Call*Method</code> 等直接调用 Java 代码。而 FFM 对这类回调暂时支持有限（需使用 <code>Linker.upcallStub</code> 生成回调函数指针，流程较复杂）。因此，在需要频繁从本地代码调用 Java 的场景（如 Signal 处理、线程回调）时，JNI 仍具优势。</li>
</ul>
<p>综上，<strong>FFM 使得大部分情况下无需修改现有 C 代码</strong>——只要 C 库已编译好，就可以直接在 Java 侧调用；而 JNI 则通常需要为每个方法写特定的 native 函数签名。这一点使得 FFM 迁移成本较低：只修改 Java 端调用方式，C 端实现可以不变。</p>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>
<p><strong>使用 FFM API 的情景</strong>：</p>
<ul>
<li><strong>新开发或迁移现有库</strong>：如果需要调用已有的 C/C++ 库（如系统 API、第三方算法库、图形/AI 框架等），FFM 提供了更安全简洁的访问方式。对于新项目，推荐优先采用 FFM API 进行本地互操作。Java 文档也建议在适用的情况下优先使用 FFM 以取代 JNI。</li>
<li><strong>高性能需求</strong>：在需要充分发挥现代硬件能力的场景（例如大数据处理、向量运算、视频/图形计算），FFM 可以利用底层优化（如 SIMD、内存对齐）获得接近原生的性能。</li>
<li><strong>安全与快速迭代</strong>：如果项目对稳定性和安全性要求较高，需要减少低级内存错误，可选用 FFM 以获得自动内存管理和类型安全的好处。同时，由于无需编写 C 代码，可以用纯 Java 快速迭代、本地部署更方便。</li>
</ul>
</li>
<li>
<p><strong>使用 JNI 的情景</strong>：</p>
<ul>
<li><strong>遗留系统或特殊需求</strong>：如果已有大量 JNI 代码、或者需要使用一些 FFM 目前不支持的功能（如直接操作 Java 对象、利用 JNI 注册回调 Java 方法、调用某些只提供 JNI 接口的库），可以继续使用 JNI。对于现有的 JNI 库，可以逐步评估迁移成本；有时直接调用 JNI 更快捷。</li>
<li><strong>Java 嵌入场景</strong>：在使用 JNI 调用 Java 虚拟机（JNI Invocation API）将 JVM 嵌入到本地应用中时，需要依赖 JNI 接口。提到 JNI 在这种嵌入式使用下的优势。</li>
<li><strong>极端性能调优</strong>：虽然 FFM 在大部分场景中性能已经优秀，但在极端苛刻的低延迟场合，经验丰富的 C/C++ 开发者可能仍会选择手动优化 JNI 调用路径（如缓存 <code>JNIEnv*</code> 指针、最小化 JNI 调用开销）。</li>
</ul>
</li>
</ul>
<p>总的来说，对于大多数新项目和常见用途（<strong>调用本地库、处理本地数据</strong>），FFM API 是更优的选择；而 JNI 主要适用于传统/特殊场景或过渡阶段。随着 JDK 23 及以后版本对 JNI 的使用越来越多限制（例如默认对 JNI 调用发出警告或抛出异常），Java 平台正逐步鼓励使用 FFM API。因此，开发者应在新功能开发时优先考虑 FFM，在必须时才使用 JNI，以保持代码现代性和安全性。</p>  </article> <div class="tags"> <div class="_tailmateTag_u5zwa_5"> <a href="/blog/tag/Kotlin/">Kotlin</a> </div><div class="_tailmateTag_u5zwa_5"> <a href="/blog/tag/FFM API/">FFM API</a> </div><div class="_tailmateTag_u5zwa_5"> <a href="/blog/tag/JNI/">JNI</a> </div><div class="_tailmateTag_u5zwa_5"> <a href="/blog/tag/跨语言互操作/">跨语言互操作</a> </div><div class="_tailmateTag_u5zwa_5"> <a href="/blog/tag/性能优化/">性能优化</a> </div><div class="_tailmateTag_u5zwa_5"> <a href="/blog/tag/内存管理/">内存管理</a> </div><div class="_tailmateTag_u5zwa_5"> <a href="/blog/tag/系统编程/">系统编程</a> </div> </div> </main> </div> <div class="okTgGW_footer"> <p>Supported and developed by&nbsp;
<a href="https://github.com/misakamayako/" target="_blank" rel="noreferrer">misaka mayako</a> </p> <p>
Tech with <a href="https://astro.build/" target="_blank" rel="noreferrer">astro</a>,&nbsp;
<a href="https://tailwindcss.com/" target="_blank" rel="noreferrer">tailwindcss</a>,&nbsp;
        and <a href="https://pm2.keymetrics.io/" target="_blank" rel="noreferrer">pm2</a>,&nbsp;
</p> <p> feed back via <a href="mailto:misakamayaco@qq.com" target="_blank" rel="noreferrer">📫</a></p> <a rel="license noreferrer" href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" class="absolute right-6 bottom-6"> <img alt="知识共享许可协议" class="inlin-block border-0" src="/cc4.0.png"> </a> </div> </div> <script type="module" is:global>
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('pre').forEach((block) => {
                const button = document.createElement('button')
                button.innerText = '复制'
                button.className =
                    'absolute top-2 right-2 bg-slate-800 text-white px-2 py-1 rounded text-sm opacity-50 hover:opacity-100 transition cursor-pointer'
                button.addEventListener('click', () => {
                    const code = block.querySelector('code')
                    if (code) {
                        navigator.clipboard.writeText(code.innerText).then(() => {
                            button.innerText = '已复制！'
                            setTimeout(() => (button.innerText = '复制'), 1000)
                        })
                    }
                })
                block.classList.add('relative')
                block.appendChild(button)
            })
        })
    </script>  </body></html>