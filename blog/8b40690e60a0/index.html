<!DOCTYPE html><html lang="zh-hans" class="h-full w-full m-0"> <head><meta charset="utf-8"><link rel="icon" type="image/jepg" href="/favicon.jpg"><meta name="viewport" content="width=device-width"><meta name="google-site-verification" content="-RgOsAO7rMTpJ8vNk8-ILdAA8VmiTEUc9HiUVVTKeEs"><meta name="generator" content="Astro v5.12.0"><title>✨御坂网络-BroadcastChannel API 概述✨</title><link rel="stylesheet" href="/_astro/index.DbbbHqKR.css">
<style>/*! tailwindcss v4.0.9 | MIT License | https://tailwindcss.com */
.okTgGW_footer{font-size:var(--text-sm,.875rem);line-height:var(--tw-leading,var(--text-sm--line-height,calc(1.25/.875)));color:var(--color-stone-400,#a6a09b);text-align:center;padding-block:calc(var(--spacing,.25rem)*4);border-top-color:var(--color-zinc-50,#fafafa);border-top-style:var(--tw-border-style);background-color:var(--color-slate-900,#0f172b);border-top-width:2px;width:100%;position:relative}@supports (color:color(display-p3 0 0 0)){.okTgGW_footer{color:var(--color-stone-400,color(display-p3 .647628 .627105 .61098));border-top-color:var(--color-zinc-50,color(display-p3 .980256 .980256 .980256));background-color:var(--color-slate-900,color(display-p3 .0639692 .0891152 .163036))}}@supports (color:lab(0% 0 0)){.okTgGW_footer{color:var(--color-stone-400,lab(66.2166% 1.88047 3.20326));border-top-color:var(--color-zinc-50,lab(98.26% -.0000298023 0));background-color:var(--color-slate-900,lab(7.78673% 1.82345 -15.0537))}}.okTgGW_footer a{text-decoration-line:underline}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}
/*! tailwindcss v4.0.9 | MIT License | https://tailwindcss.com */
.q0UmqG_menu{height:calc(var(--spacing,.25rem)*16);padding-right:calc(var(--spacing,.25rem)*16);border-bottom-color:var(--color-zinc-50,#fafafa);border-bottom-style:var(--tw-border-style);text-align:right;border-bottom-width:2px}@supports (color:color(display-p3 0 0 0)){.q0UmqG_menu{border-bottom-color:var(--color-zinc-50,color(display-p3 .980256 .980256 .980256))}}@supports (color:lab(0% 0 0)){.q0UmqG_menu{border-bottom-color:var(--color-zinc-50,lab(98.26% -.0000298023 0))}}.q0UmqG_menu a{padding-inline:calc(var(--spacing,.25rem)*2);padding-block:calc(var(--spacing,.25rem)*2);font-size:var(--text-xl,1.25rem);line-height:var(--tw-leading,var(--text-xl--line-height,calc(1.75/1.25)));color:var(--color-zinc-50,#fafafa);margin-top:calc(var(--spacing,.25rem)*2.5);display:inline-block}@supports (color:color(display-p3 0 0 0)){.q0UmqG_menu a{color:var(--color-zinc-50,color(display-p3 .980256 .980256 .980256))}}@supports (color:lab(0% 0 0)){.q0UmqG_menu a{color:var(--color-zinc-50,lab(98.26% -.0000298023 0))}}@media (hover:hover){.q0UmqG_menu a:hover{--tw-translate-y:calc(var(--spacing,.25rem)*-.5);translate:var(--tw-translate-x)var(--tw-translate-y);color:var(--color-sky-500,#00a5ef)}@supports (color:color(display-p3 0 0 0)){.q0UmqG_menu a:hover{color:var(--color-sky-500,color(display-p3 .219113 .639027 .931479))}}@supports (color:lab(0% 0 0)){.q0UmqG_menu a:hover{color:var(--color-sky-500,lab(63.3038% -18.433 -51.0407))}}}.q0UmqG_menu a{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function,cubic-bezier(.4,0,.2,1)));transition-duration:var(--tw-duration,var(--default-transition-duration,.15s));transition-property:transform,translate,scale,rotate;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function,cubic-bezier(.4,0,.2,1)));transition-duration:var(--tw-duration,var(--default-transition-duration,.15s))}.q0UmqG_navLink{padding-inline:calc(var(--spacing,.25rem)*2);padding-block:calc(var(--spacing,.25rem)*2);font-size:var(--text-xl,1.25rem);line-height:var(--tw-leading,var(--text-xl--line-height,calc(1.75/1.25)));color:var(--color-zinc-50,#fafafa);margin-top:calc(var(--spacing,.25rem)*2.5);display:inline-block}@supports (color:color(display-p3 0 0 0)){.q0UmqG_navLink{color:var(--color-zinc-50,color(display-p3 .980256 .980256 .980256))}}@supports (color:lab(0% 0 0)){.q0UmqG_navLink{color:var(--color-zinc-50,lab(98.26% -.0000298023 0))}}@media (hover:hover){.q0UmqG_navLink:hover{color:var(--color-sky-500,#00a5ef)}@supports (color:color(display-p3 0 0 0)){.q0UmqG_navLink:hover{color:var(--color-sky-500,color(display-p3 .219113 .639027 .931479))}}@supports (color:lab(0% 0 0)){.q0UmqG_navLink:hover{color:var(--color-sky-500,lab(63.3038% -18.433 -51.0407))}}}.q0UmqG_navLink{transition:color .4s}.q0UmqG_avatar{float:right;border-radius:.25rem;display:inline-block;overflow:hidden}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-translate-x{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-y{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-z{syntax:"*";inherits:false;initial-value:0}
</style>
<link rel="stylesheet" href="/_astro/_slug_.DDqNTp95.css"><script type="module" src="/_astro/page.V2R8AmkL.js"></script></head> <body class="w-full h-full flex flex-col">  <div class="bg-slate-800 h-screen flex flex-col"> <div class="bg-slate-700 w-full"> <div class="q0UmqG_avatar"> <img src="/favicon.jpg" width="64" height="64" alt=""> </div> <nav class="q0UmqG_menu"> <a href="/" class="q0UmqG_navLink">home</a> <a href="/blog/" class="q0UmqG_navLink">blog</a> <a href="/utils/" class="q0UmqG_navLink">utils</a> <a href="/dream-map/" class="inline-block">dream map</a> <a href="/album/" class="q0UmqG_navLink">album</a> <a href="/about-me/" class="q0UmqG_navLink">about me</a> </nav> </div> <div class="flex p-4 grow flex-row h-full overflow-hidden"> <aside class="w-1/4 ml-4 md:block min-w-[200px]"> <div class="sticky top-4 space-y-6"> <div class="bg-slate-700 p-4 rounded-lg"> <img src="/avatar.jpg" class="w-16 h-16 rounded-full mx-auto"> <p class="text-white text-center mt-2">作者：misakamayako</p>  <p class="text-white text-center mt-2">发布时间：2025/05/20</p> </div> <div class="bg-slate-700 p-4 rounded-lg"> <h3 class="text-emerald-400 mb-2">简介</h3> <p class="text-white font-light mb-2">本文详细介绍了 BroadcastChannel API 的用法、特性、浏览器兼容性及与其他前端通信方式的对比，帮助开发者理解如何在同源多页面环境中高效实现消息广播。</p> </div> <!-- 2. 文章目录 --> <!--<div class="bg-slate-700 p-4 rounded-lg">--> <!--    <h3 class="text-emerald-400 mb-2">本文目录</h3>--> <!--    &lt;!&ndash;<TOC client:load /> &ndash;&gt;--> <!--</div>--> <!-- 3. 随机文章 --> <div class="bg-slate-700 p-4 rounded-lg"> <h3 class="text-emerald-400 mb-2">随便看看</h3> <div class="flex flex-wrap gap-2"> <a class="px-3 py-1 bg-slate-600 rounded-full text-sm text-white hover:bg-emerald-500 transition" href="/blog/2ed8a0ceb014/"> WebGPU vs CPU：并行计算性能实测对比 </a><a class="px-3 py-1 bg-slate-600 rounded-full text-sm text-white hover:bg-emerald-500 transition" href="/blog/7631b3f6f737/"> axios在node环境中使用时不能正确访问本地服务的问题 </a><a class="px-3 py-1 bg-slate-600 rounded-full text-sm text-white hover:bg-emerald-500 transition" href="/blog/2b6de1fc1e65/"> 基于Kotlin协程的高效异步文件上传服务设计与实现 </a> </div> </div> </div> </aside> <main class="grow h-full overflow-auto w-3/4 px-8"> <article class="text-white mb-2 prose lg:prose-xl prose-stone
                 prose-headings:text-white prose-strong:text-white prose-code:text-white
                 prose-a:text-violet-200 prose-blockquote:text-stone-100">  <header> <h1>BroadcastChannel API 概述</h1> </header> <p><strong>BroadcastChannel API</strong> 是一项浏览器 Web API，允许同一来源（origin）下的不同浏览上下文（如多个标签页、iframe、<code>window.open</code> 打开的窗口，甚至同源的 Worker）之间进行消息广播通信。所有加入同一频道（channel）名称的上下文都能彼此收发消息。</p>
<h2 id="创建频道与监听消息">创建频道与监听消息</h2>
<ul>
<li>使用 <code>new BroadcastChannel(name)</code> 创建或加入一个广播频道。其中 <code>name</code> 为频道标识，字符串形式。例如：</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> channel</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> BroadcastChannel</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'my_channel'</span><span style="color:#E1E4E8">);</span></span></code></pre>
<p>只要存在至少一个上下文使用该名称创建频道，底层通道即被打开。</p>
<ul>
<li>在频道对象上，可以用 <code>onmessage</code> 或 <code>addEventListener('message', handler)</code> 监听消息事件。例如：</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#E1E4E8">channel.</span><span style="color:#B392F0">onmessage</span><span style="color:#F97583"> =</span><span style="color:#FFAB70"> event</span><span style="color:#F97583"> =></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'收到消息：'</span><span style="color:#E1E4E8">, event.data);</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span></code></pre>
<p>当其他同名频道调用 <code>postMessage()</code> 发送消息时，所有监听该频道的上下文（包括本上下文自身）都会触发 <code>message</code> 事件。</p>
<ul>
<li>若要退出频道，调用 <code>channel.close()</code>。该方法会“终止与底层频道的连接，从而允许对对象进行垃圾回收”。关闭频道后，当前上下文不再接收该频道的新消息。</li>
</ul>
<h2 id="发送消息">发送消息</h2>
<ul>
<li>向频道广播消息只需调用 <code>postMessage(data)</code>：</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#E1E4E8">channel.</span><span style="color:#B392F0">postMessage</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'这是一条测试消息'</span><span style="color:#E1E4E8">);</span></span></code></pre>
<p>消息可为任意类型的数据（遵循<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Structured_clone_algorithm">结构化克隆算法</a>），包括对象、数组、Blob、File、ArrayBuffer 等。发送端无需指定目标，消息会自动发送给所有监听该频道的上下文。</p>
<ul>
<li>接收端通过 <code>message</code> 事件对象的 <code>event.data</code> 属性获取消息内容，例如：</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#E1E4E8">channel.</span><span style="color:#B392F0">onmessage</span><span style="color:#F97583"> =</span><span style="color:#FFAB70"> event</span><span style="color:#F97583"> =></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'接收到：'</span><span style="color:#E1E4E8">, event.data);</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span></code></pre>
<ul>
<li><strong>注意</strong>：消息内容通过浏览器内部的结构化克隆算法传输，因此函数、Symbol 等不可克隆类型会被丢弃。发送大型复杂对象会消耗更多资源，可能会影响性能。</li>
</ul>
<h2 id="示例演示">示例演示</h2>
<p>下面给出一个简单示例：假设在两个同源页面（或窗口）中分别运行以下脚本，它们都订阅了频道 <code>"demo_channel"</code>。</p>
<ul>
<li><strong>页面 A 脚本：</strong></li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> bcA</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> BroadcastChannel</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'demo_channel'</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">bcA.</span><span style="color:#B392F0">onmessage</span><span style="color:#F97583"> =</span><span style="color:#FFAB70"> e</span><span style="color:#F97583"> =></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'页面 A 收到：'</span><span style="color:#E1E4E8">, e.data);</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span>
<span class="line"><span style="color:#6A737D">// 页面 A 主动发送消息</span></span>
<span class="line"><span style="color:#E1E4E8">bcA.</span><span style="color:#B392F0">postMessage</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'你好，页面 B！'</span><span style="color:#E1E4E8">);</span></span></code></pre>
<ul>
<li><strong>页面 B 脚本：</strong></li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> bcB</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> BroadcastChannel</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'demo_channel'</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">bcB.</span><span style="color:#B392F0">onmessage</span><span style="color:#F97583"> =</span><span style="color:#FFAB70"> e</span><span style="color:#F97583"> =></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'页面 B 收到：'</span><span style="color:#E1E4E8">, e.data);</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span>
<span class="line"><span style="color:#6A737D">// 页面 B 发送消息</span></span>
<span class="line"><span style="color:#E1E4E8">bcB.</span><span style="color:#B392F0">postMessage</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'页面 A，你好！'</span><span style="color:#E1E4E8">);</span></span></code></pre>
<p>在这个例子中，页面 A 发送的消息会被页面 B 接收，同样页面 B 的消息会被页面 A 接收。开发者只需保证创建了同名的 <code>BroadcastChannel</code> 实例，并设置好 <code>onmessage</code> 处理器，即可实现多页间双向通信。</p>
<h2 id="兼容性与浏览器支持">兼容性与浏览器支持</h2>
<p>BroadcastChannel API 自 Chrome 54、Firefox 38、Opera 41 开始支持。Chrome（及Chromium Edge）、Firefox、Opera 均在其现代版本中支持此 API，而 Safari 在 15.4+（iOS Safari 同版本）开始支持。下表为主要浏览器支持情况参考：</p>
<ul>
<li><strong>Chrome / Chromium Edge</strong>：54 及以上版本支持。</li>
<li><strong>Firefox</strong>：38 及以上版本支持。</li>
<li><strong>Opera</strong>：41 及以上版本支持。</li>
<li><strong>Safari / iOS Safari</strong>：15.4 及以上版本支持。</li>
<li><strong>IE、旧版 Safari/Android 浏览器</strong>：不支持。</li>
</ul>
<p><strong>使用建议：</strong> 在使用前可通过 <code>if ('BroadcastChannel' in window)</code> 进行特性检测。对于不支持的环境，可考虑退回到 <code>localStorage+storage</code> 或其他机制方案。</p>
<h2 id="限制与注意事项">限制与注意事项</h2>
<ul>
<li><strong>同源限制</strong>：BroadcastChannel 只能在“同源”上下文间通信。具体要求是协议、域名和端口均相同。跨域页面无法通过 BroadcastChannel 直接通信。</li>
<li><strong>页面关闭</strong>：调用 <code>close()</code> 或页面卸载时，当前上下文会断开频道连接。一旦关闭，当前页就不再接收该频道的后续消息，也不会触发事件。其它页面继续广播时，即使使用<code>service worker</code>，已关闭页面无法获得这些消息。</li>
<li><strong>性能与消息大小</strong>：广播消息通过结构化克隆传输，支持复杂数据结构。与 <code>localStorage</code> 方法不同，BroadcastChannel 不受浏览器的数据大小限制。不过，过大的消息仍会占用较多资源，可能导致通信延迟或失败。根据测试，简单消息的广播延迟一般在 1–2 毫秒左右，性能开销很低。但在高频率或超大消息场景下，仍需谨慎设计以避免性能瓶颈。</li>
</ul>
<h2 id="与其他通信机制的对比">与其他通信机制的对比</h2>
<ul>
<li><strong>BroadcastChannel vs LocalStorage+storage 事件</strong>：传统跨标签页通信常用 <code>localStorage</code> 写入 + <code>storage</code> 事件监听的方式，但该方法只能发送字符串（需要手动序列化）、存在浏览器限制的存储上限，并且存取是同步操作，有时效率较低。相比之下，BroadcastChannel API 不需要读写磁盘，全程在内存中广播，支持任意可克隆对象，没有大小限制，实时性也更好（无需轮询或频繁 I/O）。</li>
<li><strong>BroadcastChannel vs postMessage</strong>：<code>window.postMessage</code> 允许跨源通信，但需要持有目标窗口的引用并指定目标 origin，使用较复杂。而 BroadcastChannel 则无需引用目标窗口，只要在各自页面创建同名频道即可，且同源保证了消息安全性，无需额外校验来源。简单场景下，BroadcastChannel 的用法更直接。但如果需要和不同 origin 的页面通信，就只能使用 <code>postMessage</code>。</li>
<li><strong>BroadcastChannel vs SharedWorker</strong>：SharedWorker 允许多个同源页面共享一个后台脚本实例，适合需要集中状态管理、锁机制或共享 WebSocket 连接的复杂场景。而 BroadcastChannel 是轻量级的广播机制，更适合简单的事件通知或状态同步任务。例如同步 UI 操作或广播通知时用 BroadcastChannel 更简便；而需要在多个页面间维护持久一致状态，SharedWorker 可能更合适。</li>
<li><strong>BroadcastChannel vs MessageChannel</strong>：MessageChannel 提供两个端口的一对一通信管道（适用于需要精确控制双向通信的场景），而 BroadcastChannel 是一对多广播模型。如果只在两个窗口间通信，二者皆可选择；但 BroadcastChannel 可自动广播给所有订阅者，使用更简单。</li>
</ul>
<p>总的来说，BroadcastChannel API 以其使用方便、一对多广播和支持多种数据类型等优点，成为同源多页面实时通信的理想方案。但需注意兼容性和同源限制，在实际开发中合理选择通信方式。</p>  </article> <div class="tags"> <div class="_tailmateTag_u5zwa_5"> <a href="/blog/tag/BroadcastChannel/">BroadcastChannel</a> </div><div class="_tailmateTag_u5zwa_5"> <a href="/blog/tag/前端通信/">前端通信</a> </div><div class="_tailmateTag_u5zwa_5"> <a href="/blog/tag/Web API/">Web API</a> </div><div class="_tailmateTag_u5zwa_5"> <a href="/blog/tag/多标签页通信/">多标签页通信</a> </div> </div> </main> </div> <div class="okTgGW_footer"> <p>Supported and developed by&nbsp;
<a href="https://github.com/misakamayako/" target="_blank" rel="noreferrer">misaka mayako</a> </p> <p>
Tech with <a href="https://astro.build/" target="_blank" rel="noreferrer">astro</a>,&nbsp;
<a href="https://tailwindcss.com/" target="_blank" rel="noreferrer">tailwindcss</a>,&nbsp;
        and <a href="https://pm2.keymetrics.io/" target="_blank" rel="noreferrer">pm2</a>,&nbsp;
</p> <p> feed back via <a href="mailto:misakamayaco@qq.com" target="_blank" rel="noreferrer">📫</a></p> <a rel="license noreferrer" href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" class="absolute right-6 bottom-6"> <img alt="知识共享许可协议" class="inlin-block border-0" src="/cc4.0.png"> </a> </div> </div> <script type="module" is:global>
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('pre').forEach((block) => {
                const button = document.createElement('button')
                button.innerText = '复制'
                button.className =
                    'absolute top-2 right-2 bg-slate-800 text-white px-2 py-1 rounded text-sm opacity-50 hover:opacity-100 transition cursor-pointer'
                button.addEventListener('click', () => {
                    const code = block.querySelector('code')
                    if (code) {
                        navigator.clipboard.writeText(code.innerText).then(() => {
                            button.innerText = '已复制！'
                            setTimeout(() => (button.innerText = '复制'), 1000)
                        })
                    }
                })
                block.classList.add('relative')
                block.appendChild(button)
            })
        })
    </script>  </body></html>