---
title: 为什么你的多模块项目一定会互相污染
description: 分了 Module 并不等于架构解耦。本文深度解析 Android 多模块开发中常见的“依赖陷阱”，提出 Feature as Library 的核心世界观。通过物理隔离、API 与 Internal 分离以及 App 壳去业务化等实战策略，彻底解决编译缓慢与模块污染问题，构建真正可扩展的软件架构。
tags:
  - "软件架构"
  - "Android"
  - "Kotlin"
  - "性能优化"
  - "JVM"
  - "后端设计"
  - "数据管理"
auth: misakamayako
slug: "057931ede756"
pubDate: 2026/01/05
seriesId: 6b16fa2b-5585-4c4d-a8cc-c17a05fd5549
seriesName: "在 Android 中构建可长期演化的 Feature 架构：从模块边界到单向数据流"
seriesOrder: 1
---

> **“如果不定义边界，熵增会吞噬一切。”**

在 Android 开发中，我经常问一个问题：“你们的项目架构是什么？”
十个人里有八个会回答：“我们用了多模块（Multi-Module）。”

继续追问：“那你们的模块之间怎么交互？”
这时候，空气通常会突然安静，或者我听到类似的回答：
* “哦，我们有一个 `Common` 模块，所有东西都在里面。”
* “`Home` 模块依赖了 `User` 模块，因为首页要显示头像。”
* “我们在 `App` 壳里写了一些胶水代码，因为有时候 A 模块需要调 B 模块的方法。”

半年后，这些项目通常会面临同一个结局：**编译速度极慢，模块间依赖成网，改一个 Data Class 导致全量重新编译。**

为什么你明明拆分了 Module，架构却依然是一团乱麻？
因为**分了 Module $\neq$ 架构解耦**。

这篇作为系列的开篇，我们要先达成一个共识：**模块边界本身，就是一种最高级别的设计决策。**

## 一、 物理隔离 vs 逻辑隔离

很多团队拆分模块的初衷非常朴素：文件太多了，把它们分装到不同的文件夹里（Gradle Module）看起来整洁一点。

这种做法我称之为 **“文件夹式的多模块”**。它最大的问题在于，开发者依然保留着 **“全局视野”**。

当你在 `feature:cart`（购物车）写代码时，IDE 告诉你 `feature:goods`（商品）就在隔壁。只要你在 `build.gradle` 里敲下一行 `implementation(project(":feature:goods"))`，你就可以直接调用商品模块的代码。

这一行代码敲下去的那一刻，你的架构就开始崩塌了。

一旦开启了“Feature 互调”的口子，业务压力会迅速把依赖网变成这就图：
`A -> B -> C -> A`

这就是**循环依赖**的温床。为了解决循环依赖，你可能会把公共部分下沉到 `Core`，久而久之，`Core` 变成了垃圾堆，里面塞满了各种业务的实体类、工具类和常量，原本的“多模块”名存实亡。

## 二、 核心世界观：Feature as Library

要解决这个问题，我们需要引入一个新的心智模型：**Feature as Library（将业务模块视为第三方库）**。

想象一下，你正在开发的 `feature:user` 模块，并不是你项目的一部分，而是一个发布在 Maven Central 上的第三方 SDK（比如像 Retrofit 那样）。

在这个设定下，你必须遵守以下铁律：

1.  **你不知道谁在用你**：你不能依赖 `:app` 壳工程，也不能依赖具体的业务场景。
2.  **你不知道谁和你在一起**：你不能假设 `:feature:chat` 和你在同一个 App 里，你绝对不能依赖其他 Feature。
3.  **你只能依赖基础设施**：你可以依赖 `:core`（因为它是 Android 标准库级别的存在）。

在这个架构下，我们的依赖关系树是非常干净的单向流动：

| 层级       | 模块              | 职责与视角                                            | 依赖规则               |
|:---------|:----------------|:-------------------------------------------------|:-------------------|
| **Top**  | **`app` (壳)**   | **上帝视角**。它知道所有 Feature 的存在，负责把它们组装起来（依赖注入、导航注册）。 | 依赖所有 `feature`     |
| **Mid**  | **`feature:*`** | **孤岛视角**。只关注自己的业务闭环。不知道其他兄弟模块的存在。                | 依赖 `core`，**绝不互赖** |
| **Base** | **`core:*`**    | **工具视角**。提供基础设施（Log, Net, UI System），完全不懂业务。     | 无项目内依赖             |

## 三、 为什么 Feature 之间坚决不能直接依赖？

你可能会问：“但是，购物车模块确实需要获取用户信息啊！如果不让依赖 `feature:user`，我怎么拿数据？”

这是一个经典误区。**“需要数据” $\neq$ “需要依赖模块”**。

当你让 `feature:cart` 直接依赖 `feature:user` 时，你付出的代价是巨大的：

1.  **编译灾难**：`User` 模块哪怕改了一行注释，`Cart` 模块也要重新编译。如果依赖链很长，增量编译就变成了全量编译。
2.  **泄露实现细节**：`Cart` 可能会不小心调用了 `User` 的内部数据库逻辑，导致两个模块在数据库层级耦合。
3.  **无法独立测试**：你很难单独运行 `Cart` 模块，因为它拖家带口。

**正确的做法是**：
定义一个**接口**（Abstractions）。

*   如果需要数据：在 `core` 或共享的 API 层定义接口 `UserProvider`。
*   如果需要跳转：在 `core` 定义路由接口。
*   **谁来实现接口？** `feature:user` 实现。
*   **谁来注入实现？** `app` 壳工程（通过 DI 容器）。

这就是为什么我们在架构图里强调 **DI Container** 必须在 `app` 层。它是唯一的胶水。

## 四、 引入 API 与 Internal：物理上的强制约束

为了从物理上杜绝“不小心依赖了实现细节”的情况，我们在后续的文章中会引入一种特殊的工程结构：**API / Internal 分离**。

```text
feature/user/
├── api/       <-- 只有这里对外可见
│   ├── model/
│   ├── UserRepository.kt (Interface)
│   └── UserGraph.kt
└── internal/  <-- 这里全是秘密
    ├── data/
    ├── presentation/
    └── di/
```

*   其他模块（如 App 壳）只能依赖 `feature:user:api`。
*   `feature:user:internal` 实现了 API，但对外部完全隐藏。

这就像 Retrofit：你只能看到 `Call<T>` 接口（API），你看不到它底层是怎么解析 Socket 的（Internal）。

这种结构强制实现了 **“接口编程”**。即便你想犯错，IDE 也会告诉你：`Unresolved reference`。

## 五、 为什么 App 壳不该有业务逻辑？

在很多项目中，`MainActivity` 承载了太多的逻辑：初始化推送、判断登录状态跳转、处理全局弹窗……

在这个架构中，**`app` 模块应该极度“愚蠢”**。

它的职责只有两个：
1.  **初始化**：启动 Application，初始化 DI 容器（Koin/Hilt）。
2.  **聚合**：把各个 `feature` 的导航图（Graph）拼在一起。

如果 `app` 模块里出现了 `if (isLogin) { ... }` 这样的业务判断，说明你的架构漏水了。这些逻辑应该下沉到 `Core` 的中间件或者特定的 `Feature` 中。

## 六、 总结

这一篇我们没有写一行代码，但我们确立了最重要的架构原则：

1.  **Feature 之间是老死不相往来的孤岛**。
2.  **通讯靠接口，组装靠 App 壳**。
3.  **Core 是地基，不是垃圾桶**。

这种严苛的边界划分，起初会让你觉得“写个代码怎么这么麻烦，还要定义接口”。但随着项目演进到几十个模块、几十万行代码时，你会感谢这种边界。因为它保证了你的**编译速度**，保证了模块的**可替换性**，更保证了新加入的同事不会把代码写成一团乱麻。

确立了世界观后，下一篇我们将目光投向最底层。我们将探讨那个最容易被写乱的模块 —— **Core**。

**下一篇：[《Core 模块不是工具箱：Android 架构里的“地基层”该放什么》](/blog/45493f6eef9d/)**
